ext {
    versionMajor = 0
    versionMinor = 1
    versionPoint = 0
}

buildscript {
    ext {
        logbackLoglevel='DEBUG'

        springBootVersion = '1.5.3.RELEASE'
        springVersion = '4.3.8.RELEASE'
        jacksonVersion='2.8.8'
        retrofitVersion='2.3.0'
        slf4jVersion='1.7.25'
        logbackVersion='1.2.3'

        jUnitVersion='4.12'
        hamcrestVersion='1.3'
    }
    repositories {
  	    jcenter()
    }
    dependencies {
        classpath "net.sf.gapt:apt:1"
        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7.3'
    }
}

allprojects {
    group 'fi.oulumo.ngrok'
    version computeVersion()

    apply plugin: 'jacoco'

    repositories {
	      jcenter()
    }
}

subprojects {
    ext {
        asciiDocOutputDir = file("${buildDir}/asciidoc")
    }

    apply plugin: 'maven'
    apply plugin: 'java'
    apply plugin: 'net.sf.gapt'

    sourceCompatibility = 1.8
    targetCompatibility = 1.8

    test {
        testLogging {
            exceptionFormat = 'full'
        }
    }

    compileJava.dependsOn(processResources)

    processResources {
        filesMatching('**/logback.xml') {
            filter {
                it.replace('${logback.loglevel}', logbackLoglevel)
            }
        }
    }

    jacocoTestReport {
        reports {
            xml.enabled false
            csv.enabled false
            html.enabled true
        }

        afterEvaluate {
            classDirectories = files(classDirectories.files.collect {
                fileTree(dir: it,
                        exclude: ['**/*_MembersInjector**', '**/*_Factory**'])
            })
        }
    }
}

configure(subprojects) {
    apply plugin: 'com.jfrog.bintray'

    task sourceJar(type: Jar) {
        from sourceSets.main.allSource
        classifier = 'sources'
    }

    task javadocJar(type: Jar, dependsOn: javadoc) {
        from javadoc.destinationDir
        classifier = 'javadoc'
    }

    // Add the sourceJars to non-extractor modules
    artifacts {
        archives jar
        archives sourceJar
        archives javadocJar
    }

    bintray {
        user = "${bintray_user}"
        key = "${bintray_apikey}"
        configurations = ['archives']
        dryRun = !(project.hasProperty('pushBintray'))
        publish = true
        override = true

        pkg {
            repo = 'ngrok'
            name = "fi.oulumo.ngrok:${project.name}"
            desc = "${project.name}"
            labels = ['ngrok']
            publicDownloadNumbers = true

            githubRepo = 'Oulumo/ngrok'
            githubReleaseNotesFile = 'README.adoc'

            version {
                name = computeVersion()
                released  = new Date()
                licenses = ['Apache-2.0']
                websiteUrl = 'https://github.com/Oulumo/ngrok'
                issueTrackerUrl = 'https://github.com/Oulumo/ngrok/issues'
                vcsUrl = 'https://github.com/Oulumo/ngrok.git'
            }
        }
    }
}

task codeCoverageReport(type: JacocoReport) {
    additionalSourceDirs = files(subprojects.sourceSets.main.allSource.srcDirs)
    sourceDirectories = files(subprojects.sourceSets.main.allSource.srcDirs)
    classDirectories = files(subprojects.sourceSets.main.output)
    executionData = files(subprojects.jacocoTestReport.executionData)
    reports {
        html.enabled = true
        html.destination "${buildDir}/reports/jacoco"
        xml.enabled = true
        csv.enabled = false
    }
    onlyIf = {
        true
    }
    doFirst {
        executionData = files(executionData.findAll {
            it.exists()
        })
    }
    afterEvaluate {
        classDirectories = files(classDirectories.files.collect {
            fileTree(dir: it,
                    exclude: ['**/*_MembersInjector**', '**/*_Factory**', '**/Dagger**'])
        })
    }
}

task testReport(type: TestReport) {
    destinationDir = file("$buildDir/reports/allTests")
    // Include the results from the 'test' task in all subprojects
    reportOn subprojects.collect { it.tasks.withType(Test) }
}

task wrapper(type: Wrapper) {
    gradleVersion = '3.5'
}

def computeVersion() {
    // Version format: <major>.<minor>.<point>.<build>
    return String.format('%d.%d.%d.%d', versionMajor, versionMinor, versionPoint, getBuildNumber())
}

def getBuildNumber() {
    return Integer.valueOf(System.env.BUILD_NUMBER ?: (System.env.BUILDKITE_BUILD_NUMBER ?: 0))
}
